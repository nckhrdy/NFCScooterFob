# Code Readme

As usual, the code is written for an ESP32 microcontroller and includes definitions for pins and features such as PWM output, UART communication, hardware interrupts, LED output, and a timer. The code initializes and configures these features and sets up event handlers to respond to button presses and timer events. Additionally, the code includes UDP client configurations for sending and receiving messages over WiFi.

Overall, the code is meant to control a secure key FOB. The timer controls the locked/unlocked light states (red, green, yellow), and the RGB LED shows the current state which is related to the key indications. The device also sends and receives UART payloads and generates an IR signal using PWM. The onboard LED blinks the device ID, which can be changed by pressing a button. The code also includes a checksum function for validating messages.

The wifi_init() module initializes the Wi-Fi module on the ESP32 microcontroller. It sets up the Wi-Fi network and establishes a connection to the access point (AP) specified in the WIFI_SSID and WIFI_PASS parameters.

The udp_server_task()  listens for incoming messages on a specific port. The server task creates a socket and binds it to a specific port, and then listens for incoming messages using the recvfrom() function. When a message is received, the task prints out information about the source of the message and the content of the message.

This code initializes and creates tasks for various components of the traffic light system, including the LED lights, button, timer, and UART communication. It also creates a UDP server task for receiving data from a remote host.

In the led_init() function, GPIO pins are configured as outputs and interrupts are disabled. In alarm_init(), a timer is configured with a frequency of 1MHz and an alarm callback function is set. In button_init(), GPIO pins are configured as inputs and interrupts are set to trigger on a rising edge. A queue is also created to handle GPIO events from the ISR.

Four tasks are created to handle different aspects of the system: button_task() to rotate through the FIB sequence, send_task() to send data via UART, recv_task() to receive data via UART, and led_task() to control the LED lights based on the current traffic state. A timer_evt_task() is also created to handle timer-based events. It runs in an infinite loop, waiting for a message to send/recieve, and sends/recieves the message as soon as one is available. We also have button_task() which creates a button task that listens for button presses on the fob. When a button is pressed, it triggers the authentication process with the scooter (unlock), as well as when we want the flow of the system to stop (lock).

A UDP server task udp_server_task() is created to receive data from a remote host. The main function initializes various components of the system, creates the tasks, and enters an infinite loop where it sends data via UDP to a remote host every second.

Our NFC scooter key is intended to improve security by requiring proximity to the selected scooter and the use of near field communications (NFC) which are more difficult to intercept as an "eavesdropper". The system involves an NFC device comprised of IR LEDs and IR receivers hosted on an ESP, and a RPi with pi camera to decode a local QR code with the scooter ID (SID) to solve the 'provisioning' problem. The flow is initiated by a button press on the fob that communicates to the scooter (and RPi) to start the process. Then the scooter expects to receive a key from the authentication server, which validates the FIB and SID pair and then creates a random key that is sent back to the fob and to the scooter via separate messages. Upon receiving the key, the fob indicates, via LED, that it is ready to communicate the key to the scooter. On button press, the FIB and key are sent to the scooter, which compares the keys sent via different paths. If they match, the scooter indicates success via LED.
